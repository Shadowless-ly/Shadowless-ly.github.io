<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python日志模块logging使用介绍]]></title>
    <url>%2Fpython%2Fpython%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[在平时编写Python脚本时，需要调试就加print打印出来观察，这种操作在写一些简单的脚本时是迅速有效的。但是当进行复杂的应用开发时，这样调试就显得力不从心。所以我们需要使用Python标准库中的logging模块，该模块可以定义日志格式，设置过滤信息，选择日志输出位置（文件、标准错误输出、网络等等）。 使用基本的logging配置在一般使用过程中，我们需要按照事件的严重程度将日志划分不同等级，便于我们观察和定位。logging内置的日志级别为：1234567import logginglogging.debug("debug message")logging.info("info message")logging.warning("warning message")logging.error("error message")logging.critical("critical message") 日志级别的数字值： 级别 数字值 CRITICAL 50 ERROR 40 WARNING 30 INFO 20 DEBUG 10 NOTSET 0 logging模块中的还有以下几个概念，Handler，Formater，Filter，Logger。 Handler: 日志处理器。处理日志信息的输出位置。 Formater：日志的格式化。设置日志的输出格式。 Filter: 日志过滤器。为日志设置过滤条件。 Logger： 日志记录器。在应用中使用该接口记录日志。 首先我们开始最基本的日志配置： 定义日志等级，在默认情况下，只有日志级别在WARNING及以上的信息才会被处理，所以我们需要设置适合的等级。 设置日志的输出格式 设置日志的输出位置 以上三项设置，我们可以直接调用logging模块中的basicConfig方法，该方法会设置全局日志处理器root_handler,全局日志记录器root_logger,并依据制定参数设置Formater作为root_handler的格式化器。 使用方法： log_basic.py123456789101112131415import logginglogging.basicConfig(level=logging.INFO, format="%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s", datefmt="%a, %d %b %Y %H:%M:%S", filename='parser_result.log', filemode='w' )logging.info("info message")logging.debug("debug message")logging.warning("warning message")logging.error("error message")logging.critical("critical message") 按照上述参数我们可以在parser_result.log文件中获得以下内容： 1234Sun, 17 Jun 2018 01:07:17 log_basic.py[line:10] INFO info messageSun, 17 Jun 2018 01:07:17 log_basic.py[line:12] WARNING warning messageSun, 17 Jun 2018 01:07:17 log_basic.py[line:13] ERROR error messageSun, 17 Jun 2018 01:07:17 log_basic.py[line:14] CRITICAL critical message 如果需要将日志打印在终端上，我们可以修改上述例子: log_basic.py1234567891011121314import loggingimport syslogging.basicConfig(level=logging.INFO, format="%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s", datefmt="%a, %d %b %Y %H:%M:%S", stream=sys.stdout )logging.info("info message")logging.debug("debug message")logging.warning("warning message")logging.error("error message")logging.critical("critical message") Basic的参数介绍如下basicConfig参数1234567891011121314151617filename: 指定日志文件名;filemode: 和file函数意义相同，制定日志文件的打开模式，'w' or 'a';format: 指定输出的格式和内容. %(levelno)s: 日志级别数值 %(levelname)s:日志级别名称 %(pathname)s:当前程序路径，sys.argv[0] %(filename)s:当前执行程序名 %(funcName)s:日志的当前函数 %(lineno)s:当前行号 %(asctime)s:日志时间 %(thread)d:线程ID %(threadName)s:线程名称 %(process)d:进程ID %(message)s:日志信息datafmp: 指定时间格式，同time.strftime();level: 设置日志级别，默认logging.WARNNING;stream: 指定将日志的输出流，可以sys.stderr,sys.stdout或文件，默认sys.stderr,当filename也指定，stream被忽略； 基本的设置使用logging.basic即可完成，后面介绍由Handler，Formater，Filter，Logger这些更细致的配置。 日志记录器Logger的使用Logger为logging模块中的日志记录器，主要执行三项工作： 为程序提供日志记录的接口 判断日志所处级别，并判断是否需要过滤 根据日志级别将该条日志分别发给不同Handler 常用的方法为： Logger.setLevel(): 设置日志等级 Logger.addHandler(): 添加一个Handler Logger.removeHandler(): 删除一个Handler Logger.addFilter(): 添加一个过滤器 使用Logger.getLogger()可以获取一个Logger，如果未提供参数则获得root Logger。logging.getLogger(&quot;APP&quot;)获得一个名为APP的日志记录器logging.getLogger(&quot;APP.run&quot;)获得名为APP.run的记录器，该记录器为APP的子记录器 示例代码如下：logging_logger.py12345678910111213141516171819202122232425262728293031import loggingimport sysdef app(): app_logger = logging.getLogger("APP") app_logger.setLevel(logging.INFO) app_formater = logging.Formatter("%(name)s - %(asctime)s - %(filename)s: %(message)s") app_handler = logging.StreamHandler(sys.stdout) app_handler.setFormatter(app_formater) app_logger.addHandler(app_handler) app_logger.info("APP config ...")def run(): run_logger = logging.getLogger("APP.run") run_logger.setLevel(logging.INFO) run_formater = logging.Formatter("%(name)s - %(asctime)s - %(filename)s: %(message)s") run_handler = logging.StreamHandler() run_handler.setFormatter(run_formater) run_logger.addHandler(run_handler) run_logger.info("running now!") def main(): app() run()if __name__ == '__main__': main() 执行代码输出如下： 1234shadowless@shadowless-PC:$ python logging_logger.pyAPP - 2018-06-17 22:25:11,541 - logging_logger.py: APP config ...APP.run - 2018-06-17 22:25:11,542 - logging_logger.py: running now!APP.run - 2018-06-17 22:25:11,542 - logging_logger.py: running now! 观察输出结果，为何会有两条unning now的打印，这是因为默认情况下，一个logger名为propagate属性，当该属性值为True则该logger的输出会朝着上一级传播，最终都会交给root Logger。有如下解决方案： 在创建logger时将propagate属性置为False。 将APP.run的Handler移除，全部日志都交给APP Logger的处理器去输出。 一般情况下，为了使程序日志记录有调理，我们也可以将root Logger的日志等级设置成最高，或者移除其所有日志处理器。 使用不同的Handler来处理日志的输出logging模块中内置的Handler有以下几种： 名称 作用 StreamHandler 日志输出到流，可以是sys.stderr或sys.stdout或文件 FileHandler 日志输出到文件 BaseRotatingHandler 基本的日志回滚方式 RotatingHandler 日志回滚方式，支持日志文件最大数量和日志文件回滚 TimeRotatingHandler 日志回滚方式，在一定时间区域回滚日志文件 SocketHandler 远程输出到TCP/IP sockets DatagramHandler 远程输出日志到UDP socckets SMTPHandler 远程输出日志到邮件地址 SysLogHandler 日志输出到syslog NTEventLogHandler 远程输出日志到Windows NT/2000/XP的事件日志 MemoryHandler 日志输出到内存中的指定buffer HTTPHandler 通过”get”,”post”远程输出到HTTP服务器 StreamHandler使用StreamHandler可以将日志输出到流。如标准输出流，标准错误输出流，文件等。使用方法可以参考如下例子： logging_stream.py12345678910import loggingimport sysconsole_logger = logging.getLogger()console_logger.setLevel(level=logging.INFO)formatter = logging.Formatter("%(pathname)s - %(asctime)s - %(name)s - %(levelname)s - %(message)s")console_handler = logging.StreamHandler(sys.stderr)console_handler.setFormatter(formatter)console_logger.info("输出到命令行") FileHandler使用FileHandler可以将日志输出到文件。logging_file.py123456789import loggingfile_logger = logging.getLogger()file_logger.setLevel(level=logging.INFO)formatter = logging.Formatter("%(pathname)s - %(asctime)s - %(name)s - %(levelname)s - %(message)s")file_handler = logging.FileHanlder("logging_file.log")file_handler.setFormatter(formatter)file_logger.info("输出到文件") RotatingFileHandlerlogging_rotatingfile.py123456789import loggingfile_logger = logging.getLogger()file_logger.setLevel(level=logging.INFO)formatter = logging.Formatter("%(pathname)s - %(asctime)s - %(name)s - %(levelname)s - %(message)s")file_handler = logging.handlers.RotatingFileHandler("log/logging_file.log", maxBytes=1*1024, backupCount=3)file_handler.setFormatter(formatter)file_logger.info("输出到文件,当日志达到1KB时将日志备份，总备份个数为3个，logging_file.log中始终为最新的日志") 使用Filter过滤器Handlers和Loggers可以使用Filters来完成比级别更复杂的过滤。Filter基类只允许特定Logger层次以下的事件。例如用‘A.B’初始化的Filter允许Logger ‘A.B’, ‘A.B.C’, ‘A.B.C.D’, ‘A.B.D’等记录的事件，logger‘A.BB’, ‘B.A.B’ 等就不行。 如果用空字符串来初始化，所有的事件都接受。创建方法: filter = logging.Filter(name=&#39;&#39;) 概念总结：熟悉了这些概念之后，有另外一个比较重要的事情必须清楚，即Logger是一个树形层级结构;Logger可以包含一个或多个Handler和Filter，即Logger与Handler或Fitler是一对多的关系;一个Logger实例可以新增多个Handler，一个Handler可以新增多个格式化器或多个过滤器，而且日志级别将会继承。 python logging模块使用教程好吃的野菜 示例，使用filter控制日志输出到log文件与控制台logging_filter.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import sysimport loggingclass ContextFilter(logging.Filter): """ 这是一个控制日志记录的过滤器。 """ def filter(self, record): try: filter_key = record.TASK except AttributeError: return False if filter_key == "logToConsole": return True else: return Falseif __name__ == '__main__': # 创建日志对象 logger = logging.getLogger(__name__) logger.setLevel(logging.DEBUG) # 创建日志处理器，记录日志到文件 log_path = "./log.log" file_handler = logging.FileHandler(log_path) file_handler.setLevel(logging.INFO) file_fmt = "%(asctime)-15s %(levelname)s [%(filename)s %(lineno)d] %(message)s" file_formatter = logging.Formatter(file_fmt) file_handler.setFormatter(file_formatter) logger.addHandler(file_handler) # 添加日志处理器，输出日志到控制台 console_handler = logging.StreamHandler(sys.stdout) console_handler.setLevel(logging.WARN) console_fmt = '%(asctime)-15s [%(TASK)s] %(message)s' console_formatter = logging.Formatter(console_fmt) console_handler.setFormatter(console_formatter) console_filter = ContextFilter() console_handler.addFilter(console_filter) logger.addHandler(console_handler) filter_dict = &#123;'TASK': 'logToConsole'&#125; # 记录日志 logger.debug('debug message') logger.info('info message') logger.warning('warn message') logger.error('error message1', extra=filter_dict) logger.error('error message2') logging模块工作流程 判断日志的等级是否大于Logger对象的等级，如果大于，则往下执行，否则，流程结束。 产生日志。第一步，判断是否有异常，如果有，则添加异常信息。第二步，处理日志记录方法(如debug，info等)中的占位符，即一般的字符串格式化处理。 使用注册到Logger对象中的Filters进行过滤。如果有多个过滤器，则依次过滤；只要有一个过滤器返回假，则过滤结束，且该日志信息将丢弃，不再处理，而处理流程也至此结束。否则，处理流程往下执行。 在当前Logger对象中查找Handlers，如果找不到任何Handler，则往上到该Logger对象的父Logger中查找；如果找到一个或多个Handler，则依次用Handler来处理日志信息。但在每个Handler处理日志信息过程中，会首先判断日志信息的等级是否大于该Handler的等级，如果大于，则往下执行(由Logger对象进入Handler对象中)，否则，处理流程结束。 执行Handler对象中的filter方法，该方法会依次执行注册到该Handler对象中的Filter。如果有一个Filter判断该日志信息为假，则此后的所有Filter都不再执行，而直接将该日志信息丢弃，处理流程结束。 使用Formatter类格式化最终的输出结果。 注：Formatter同上述第2步的字符串格式化不同，它会添加额外的信息，比如日志产生的时间，产生日志的源代码所在的源文件的路径等等。 真正地输出日志信息(到网络，文件，终端，邮件等)。至于输出到哪个目的地，由Handler的种类来决定。 logging的配置logging可以采用一下几种方式进行配置： 显式创建记录器Logger、处理器Handler和格式化器Formatter，并进行相关设置； 通过简单方式进行配置，使用basicConfig()函数直接进行配置； 通过配置文件进行配置，使用fileConfig()函数读取配置文件； 通过配置字典进行配置，使用dictConfig()函数读取配置信息； 通过网络进行配置，使用listen()函数进行网络配置。 参考官方文档 python 3.52中文文档 显式创建12345678910111213141516171819202122232425import logging# create loggerlogger = logging.getLogger('simple_example')logger.setLevel(logging.DEBUG)# create console handler and set level to debugch = logging.StreamHandler()ch.setLevel(logging.DEBUG)# create formatterformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')# add formatter to chch.setFormatter(formatter)# add ch to loggerlogger.addHandler(ch)# 'application' codelogger.debug('debug message')logger.info('info message')logger.warn('warn message')logger.error('error message')logger.critical('critical message') 输出如下123456$ python simple_logging_module.py2005-03-19 15:10:26,618 - simple_example - DEBUG - debug message2005-03-19 15:10:26,620 - simple_example - INFO - info message2005-03-19 15:10:26,695 - simple_example - WARNING - warn message2005-03-19 15:10:26,697 - simple_example - ERROR - error message2005-03-19 15:10:26,773 - simple_example - CRITICAL - critical message 使用ini配置文件设置1234567891011121314import loggingimport logging.configlogging.config.fileConfig('logging.conf')# create loggerlogger = logging.getLogger('simpleExample')# 'application' codelogger.debug('debug message')logger.info('info message')logger.warn('warn message')logger.error('error message')logger.critical('critical message') 配置文件如下： 12345678910111213141516171819202122232425262728[loggers]keys=root,simpleExample[handlers]keys=consoleHandler[formatters]keys=simpleFormatter[logger_root]level=DEBUGhandlers=consoleHandler[logger_simpleExample]level=DEBUGhandlers=consoleHandlerqualname=simpleExamplepropagate=0[handler_consoleHandler]class=StreamHandlerlevel=DEBUGformatter=simpleFormatterargs=(sys.stdout,)[formatter_simpleFormatter]format=%(asctime)s - %(name)s - %(levelname)s - %(message)sdatefmt= 输出如下： 123456$ python simple_logging_config.py2005-03-19 15:38:55,977 - simpleExample - DEBUG - debug message2005-03-19 15:38:55,979 - simpleExample - INFO - info message2005-03-19 15:38:56,054 - simpleExample - WARNING - warn message2005-03-19 15:38:56,055 - simpleExample - ERROR - error message2005-03-19 15:38:56,130 - simpleExample - CRITICAL - critical message fileConfig()函数有个参数disable_existing_loggers默认为True，主要是为了向后兼容。它会使fileConfig()调用之前的所有记录器被禁用，除非这些记录器或者它们的祖先显式的出现在配置之中；这也许是／不是你需要的。请参考文档以得到更多的信息，如果需要，请指定False。传递给dictConfig()的字典可以有键disable_existing_loggers，其值为布尔类型，如果没有显式的指明，其默认值为True。这会导致上述的记录器禁用行为，也许不是你希望的，这种情况下将其值设为False。 使用Dict，Json，YAML 在Python 3.2中，引入了一种新的配置日志记录的方法，使用字典来保存配置信息。它提供的功能是上述的基于文件的配置的功能的超集，推荐在新的应用和部署中使用。因为用Python的字典来保存配置信息，而你可以用不同的方法来产生字典，所以你有更多的配置选择。例如你可以使用JSON格式的配置文件，或者使用YAML格式的文件来产生配置字典。或者你可以用Python代码来构造字典，从socket中接受它的pickle形式（Python一种序列化机制），或者任何对你的应用有意义的方式来构造字典。 使用YAML格式： 123456789101112131415161718version: 1formatters: simple: format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'handlers: console: class: logging.StreamHandler level: DEBUG formatter: simple stream: ext://sys.stdoutloggers: simpleExample: level: DEBUG handlers: [console] propagate: noroot: level: DEBUG handlers: [console]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python使用configparser解析配置文件]]></title>
    <url>%2Fpython%2FPython%E4%BD%BF%E7%94%A8configparser%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在linux中，有很多工具拥有自己的配置文件，如：vim的配置文件~/.vimrc,pip的配置文件~/.pip/pip.conf,MySQL客户端的配置文件/etc/mysql/my.conf等等。 ini配置文件使用配置文件，我们就无需每次启动设置参数。而且典型的ini配置文件与编程语言无关，可读性强。 ini配置文件格式如下config.ini12345678910111213[client]port = 3306user = mysqlpassword = mysqlhost = 127.0.0.1[mysqld]basedir = /usrdatadir = /var/lib/mysqltmpdir = /tmpskip-external-locking# 注释 其中[client]和[mysqld]为章节(section),章节下面的port,user,password,host这些为选项(option) configparser解析配置文件我们可以使用Python的configparser模块来解析配置文件。首先我们需要将配置文件读取到内存，并创建一个ConfigParser对象。 1234import configparserp = configparser.ConfigParser(allow_no_value=True)p.read("config.ini") 以下是ConfigPaser的构造方法常用的参数:allow_no_value: 是否允许选项没有值，默认Falsedelimiters： 分隔符，接受元组，默认(“=”, “:”)comment_prefixes: 注释前缀，接受元组，默认(“#”, “;”) 在生成了ConfigParser对象后，我们可以使用其read方法从配置文件读取配置内容，也可是使用readfp方法直接从文件描述符读取。 常用的ConfigParser查询方法：sections: 返回一个包含所有section的列表has_sections: 判断章节是否存在items: 以元组的方式返回所有选项options: 返回一个包含该章节下所有选项的列表has_option: 判断某个选项是否存在get：取得选项的值getboolean：取得选项的值，boolean类型getint：取得选项的值，int类型getfloat: 取得选项的值，float类型 parse.py12345678910import configparserp = configparser.ConfigParser(allow_no_value=True)print("读取配置文件", p.read("./config.ini"))print("返回所有章节列表", p.sections())print("判断章节是否存在", p.has_section("client"))print("返回一个章节下所有选项的列表", p.options("client"))print("判断一个选项是否存在", p.has_option("client", "user"))print("获取选项的值", p.get("client", "host"))print("获取选项的值，以int类型返回", p.getint("client", "port")) 结果如下：1234567读取配置文件 ['./config.ini']返回所有章节列表 ['client', 'mysqld', 'test']判断章节是否存在 True返回一个章节下所有选项的列表 ['port', 'user', 'password', 'host']判断一个选项是否存在 True获取选项的值 127.0.0.1获取选项的值，以int类型返回 3306 我们还可以修改配置文件：remove_section: 删除一个章节add_section: 添加一个章节remove_option: 删除一个选项set: 添加一个选项write: 将ConfigParser中的数据写入到文件 12345678910import sysimport configparserp = configparser.ConfigParser(allow_no_value=True)print("读取配置文件", p.read("./config.ini"))print("删除一个章节", p.remove_section("client"))print("添加一个章节", p.add_section("mysql"))print("添加一个选项", p.set("mysql", "host", "localhost"))print("添加一个选项", p.set("mysql", "port", "3306"))print("写入到为文件", p.write(sys.stdout)) 1234567891011121314151617181920读取配置文件 ['./config.ini']删除一个章节 True添加一个章节 None添加一个选项 None添加一个选项 None[mysqld]basedir = /usrdatadir = /var/lib/mysqltmpdir = /tmpskip-external-locking[test]host = localhostpasswd = 123456[mysql]host = localhostport = 3306写入到为文件 None 我们还可以使用字典访问的形式便捷的取值或赋值。 1234567891011121314151617181920212223242526272829In [1]: import configparserIn [2]: p = configparser.ConfigParser(allow_no_value=True)In [3]: p.read("config.ini")Out[3]: ['config.ini']In [4]: p["client"]["port"]Out[4]: '3306'In [5]: p["client"]Out[5]: &lt;Section: client&gt;In [6]: p["client"].items()Out[6]: ItemsView(&lt;Section: client&gt;)In [7]: p["client"]["host"]Out[7]: '127.0.0.1'In [8]: p["client"].get("host", "none")Out[8]: '127.0.0.1'In [9]: p["client"].get("host1", "none")Out[9]: 'none'In [10]: p["client"]["host"] = "localhost"In [11]: p["client"].get("host", "none")Out[11]: 'localhost']]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的字符串格式化]]></title>
    <url>%2Fjava%2FJava%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[整理一下Java的字符串格式化，方便日后查用。 Java格式化在Java中，数字和日期的格式化并没有结合到输出、输入功能上，因为通常显示给用户的是GUI或WEB页面，显然只绑定在命令行输出上是不能满足需求的。格式化的功能是由java.util.Formatter这个类来实现的。为了方便，我们不需要直接调用这个class上的方法，在Java 5.0以后的版本，该功能已经加入到输入输出类和String上了，我们直接调用String.format()这个静态方法传入值与格式即可。 format()方法基本介绍java.util.Formatter类的format方法有两个重载版本: format(String format, Object ... args)和format(Locale l, String format, Object ... args)，两者区别为前者使用本地语言环境，后者指定语言环境。 Formatter的用法：1234567%[argument number$][flags][width][.precision]typeargument number: 可选，是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 "1$" 引用，第二个参数由 "2$" 引用，依此类推。flags: 可选，特定类型的选项，例如数字要加逗号或正负号width: 可选，最小字符数，可以超过，不足则补齐precision:可选，精确度type:必须，类型标识 Java的格式化主要分为两大类，一类为常规类型、字符类型和数值类型，另一类为日期和时间类型。我们按照这两大类来整理。 常规类型格式化type:类型标识1System.out.println(String.format("My name is %s", "Tom")); %为占位符，s为转换符，转换类型需要与参数相兼容。 1234567891011121314151617181920212223242526272829303132333435import java.util.Formattable;import java.util.Formatter;public class TestFormat &#123; public static void main(String [] args)&#123; formatConversion(); &#125; private static void formatConversion()&#123; System.out.println(String.format("'b':将参数格式化为boolean类型输出，'B'的效果相同,但结果中字母为大写。%b",false)); System.out.println(String.format("'h':将参数格式化为散列输出，原理：Integer.toHexString(arg.hashCode())，'H'的效果相同,但结果中字母为大写。%h","ABC")); System.out.println(String.format("'s':将参数格式化为字符串输出，如果参数实现了 Formattable接口，则调用 formatTo方法。'S'的效果相同。%s",16)); System.out.println(String.format("FormatImpl类实现了Formattable接口：%s",new FormatImpl())); System.out.println(String.format("'c':将参数格式化为Unicode字符，'C'的效果相同。%c",'A')); System.out.println(String.format("'d':将参数格式化为十进制整数。%d",11)); System.out.println(String.format("'o':将参数格式化为八进制整数。%o",9)); System.out.println(String.format("'x':将参数格式化为十六进制整数。%x",17)); System.out.println(String.format("'e':将参数格式化为科学计数法的浮点数，'E'的效果相同。%E",10.000001)); System.out.println(String.format("'f':将参数格式化为十进制浮点数。%f",10.000001)); System.out.println(String.format("'g':根据具体情况，自动选择用普通表示方式还是科学计数法方式，'G'效果相同。10.01=%g",10.01)); System.out.println(String.format("'g':根据具体情况，自动选择用普通表示方式还是科学计数法方式，'G'效果相同。10.00000000005=%g",10.00000000005)); System.out.println(String.format("'a':结果被格式化为带有效位数和指数的十六进制浮点数，'A'效果相同,但结果中字母为大写。%a",10.1)); System.out.println(String.format("'t':时间日期格式化前缀，会在后面讲述")); System.out.println(String.format("'%%':输出%%。%%")); System.out.println(String.format("'n'平台独立的行分隔符。System.getProperty(\"line.separator\")可以取得平台独立的行分隔符，但是用在format中间未免显得过于烦琐了%n已经换行")); &#125; private static class FormatImpl implements Formattable &#123; @Override public void formatTo(Formatter formatter, int flags, int width, int precision) &#123; formatter.format("我是Formattable接口的实现类"); &#125; &#125;&#125; 输出结果为： 1234567891011121314151617'b':将参数格式化为boolean类型输出，'B'的效果相同,但结果中字母为大写。false'h':将参数格式化为散列输出，原理：Integer.toHexString(arg.hashCode())，'H'的效果相同,但结果中字母为大写。fc42's':将参数格式化为字符串输出，如果参数实现了 Formattable接口，则调用 formatTo方法。'S'的效果相同。16FormatImpl类实现了Formattable接口：我是Formattable接口的实现类'c':将参数格式化为Unicode字符，'C'的效果相同。A'd':将参数格式化为十进制整数。11'o':将参数格式化为八进制整数。11'x':将参数格式化为十六进制整数。11'e':将参数格式化为科学计数法的浮点数，'E'的效果相同。1.000000E+01'f':将参数格式化为十进制浮点数。10.000001'g':根据具体情况，自动选择用普通表示方式还是科学计数法方式，'G'效果相同。10.01=10.0100'g':根据具体情况，自动选择用普通表示方式还是科学计数法方式，'G'效果相同。10.00000000005=10.0000'a':结果被格式化为带有效位数和指数的十六进制浮点数，'A'效果相同,但结果中字母为大写。0x1.4333333333333p3't':时间日期格式化前缀，会在后面讲述'%':输出%。%'n'平台独立的行分隔符。System.getProperty("line.separator")可以取得平台独立的行分隔符，但是用在format中间未免显得过于烦琐了已经换行 argument number:位置参数1System.out.println(String.format(&quot;Java提供了%1$s类用于格式化，我们可以使用%1$s的%2$s方法格式化字符串。&quot;, &quot;java.util.Formatter&quot;, &quot;format()&quot;)); 结果如下： 1Java提供了java.util.Formatter类用于格式化，我们可以使用java.util.Formatter的format()方法格式化字符串。 可以使用&lt;标识重复使用之前用过的参数 1System.out.println(String.format("%s, %&lt;s, %&lt;s", "重复使用参数")); 输出如下： 1重复使用参数, 重复使用参数, 重复使用参数 flags:特定类型选项我们可以使用flags参数控制特定类型输出的格式，如左对齐，逗号隔开数字。 符号 说明 &#39;-&#39; 在最小宽度内左对齐，不可以与“用0填充”同时使用 &#39;+&#39; 结果总是包括一个符号 &#39; &#39; 正值前加空格，负值前加负号 &#39;0&#39; 结果将用零来填充 &#39;,&#39; 每3位数字之间用“，”分隔(只适用于fgG的转换) &#39;(&#39; 若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换) 123456789private static void formatFlags() &#123; System.out.println("'-':在最小宽度内左对齐，不可与\"用0填充\"同时使用。"); System.out.println(String.format("设置最小宽度为8为，左对齐。%-8d:%-8d:%-8d%n", 1, 22, 99999999)); System.out.println(String.format("'0':结果将用零来填充。设置最小宽度为8，%08d:%08d:%08d", 1, -22, 99999990)); System.out.println(String.format("'+':结果总是包括一个符号。%+d:%+d:%+d", 1, -2, 0)); System.out.println(String.format("' ':正值前加空格，负值前加负号。% d:% d:% d", 1, -2, 0)); System.out.println(String.format("',':每3位数字之间用“，”分隔(只适用于fgG的转换)。%,d:%,d:%,d", 1, 100, 1000)); System.out.println(String.format("'(':若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换)。%(d:%(d", 1, -1));&#125; 结果如下： 12345678'-':在最小宽度内左对齐，不可与"用0填充"同时使用。设置最小宽度为8为，左对齐。1 :22 :99999999'0':结果将用零来填充。设置最小宽度为8，00000001:-0000022:99999990'+':结果总是包括一个符号。+1:-2:+0' ':正值前加空格，负值前加负号。 1:-2: 0',':每3位数字之间用“，”分隔(只适用于fgG的转换)。1:100:1,000'(':若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换)。1:(1) width:设置宽度最小字幅宽度，注意，这并非总数，输出可以超过此宽度，不足则会自动补0。该值不能为0。 1System.out.println(String.format("'0':结果将用零来填充。设置最小宽度为8，%08d:%08d:%08d", 1, -22, 99999990)); 输出结果： 1'0':结果将用零来填充。设置最小宽度为8，00000001:-0000022:99999990 .precision:精确度用于控制浮点数的精确度。 1System.out.println(String.format("设置精度为2位：%.2f", 1f)); 输出如下： 1设置精度为2位：1.00 日期时间类型格式化时间日期格式化的转换符分为三类，时间格式化转换符，日期格式化转换符，时间日期格式化转换符 时间格式化时间格式化字符串格式为%[argument number$][flags][width]type其中type字段第一个字符固定为T或t。 1234567891011121314151617181920212223242526/*** 格式化时间*/private static void formatTime() &#123; System.out.println("这是格式化时间相关的，具体输出跟你执行代码时间有关"); Calendar calendar = Calendar.getInstance(); System.out.println(String.format("'H':2位数24小时制，不足两位前面补0：%tH（范围：00-23）", calendar)); System.out.println(String.format("'I':2位数12小时制，不足两位前面补0：%tI（范围：01-12）", calendar)); System.out.println(String.format("'k':24小时制，不足两位不补0：%tk（范围：0-23）", calendar)); System.out.println(String.format("'l':12小时制，不足两位不补0：%tl（范围：1-12）", calendar)); System.out.println(String.format("'M':2位数的分钟，不足两位前面补0：%tM（范围：00-59）", calendar)); System.out.println(String.format("'S':分钟中的秒，2位数，不足两位前面补0，60是支持闰秒的一个特殊值：%tS（范围：00-60）", calendar)); System.out.println(String.format("'L':3位数的毫秒，不足三位前面补0：%tL（范围：000-999）", calendar)); System.out.println(String.format("'N':9位数的微秒，不足九位前面补0：%tN（范围：000000000-999999999）", calendar)); System.out.println(String.format("'p':输出本地化的上午下午，例如，Locale.US为am或pm，Locale.CHINA为上午或下午", calendar)); System.out.println(String.format(Locale.US, "Local.US=%tp", calendar)); System.out.println(String.format(Locale.CHINA, "Local.CHINA=%tp", calendar)); System.out.println(); System.out.println(String.format("'z':时区：%tz", calendar)); System.out.println(String.format("'Z':时区缩写字符串：%tZ", calendar)); System.out.println(String.format("'s':从1970-1-1 00:00到现在所经历的秒数：%ts", calendar)); System.out.println(String.format("'Q':从1970-1-1 00:00到现在所经历的毫秒数：%tQ", calendar));&#125; 结果如下： 1234567891011121314151617这是格式化时间相关的，具体输出跟你执行代码时间有关'H':2位数24小时制，不足两位前面补0：18（范围：00-23）'I':2位数12小时制，不足两位前面补0：06（范围：01-12）'k':24小时制，不足两位不补0：18（范围：0-23）'l':12小时制，不足两位不补0：6（范围：1-12）'M':2位数的分钟，不足两位前面补0：59（范围：00-59）'S':分钟中的秒，2位数，不足两位前面补0，60是支持闰秒的一个特殊值：44（范围：00-60）'L':3位数的毫秒，不足三位前面补0：638（范围：000-999）'N':9位数的微秒，不足九位前面补0：638000000（范围：000000000-999999999）'p':输出本地化的上午下午，例如，Locale.US为am或pm，Locale.CHINA为上午或下午Local.US=pmLocal.CHINA=下午'z':时区：+0800'Z':时区缩写字符串：CST's':从1970-1-1 00:00到现在所经历的秒数：1528628384'Q':从1970-1-1 00:00到现在所经历的毫秒数：1528628384638 日期格式化12345678910111213141516171819202122private static void formatDate() &#123; System.out.println("这是格式化时间相关的，具体输出跟你执行代码时间有关"); Calendar calendar = Calendar.getInstance(); System.out.println(String.format("'B':本地化显示月份字符串，如：January、February")); System.out.println(String.format("'b':本地化显示月份字符串的缩写，如：Jan、Feb")); System.out.println(String.format("'h':本地化显示月份字符串的缩写，效果同'b'")); System.out.println(String.format(Locale.US, "Locale.US 月份=%1$tB，缩写=%1$tb", calendar)); System.out.println(String.format(Locale.CHINA, "Locale.CHINA 月份=%1$tB，缩写=%1$tb", calendar)); System.out.println(String.format("'A':本地化显示星期几字符串，如：Sunday、Monday")); System.out.println(String.format("'a':本地化显示星期几字符串的缩写，如：Sun、Mon")); System.out.println(String.format(Locale.US, "Locale.US 星期几=%1$tA，缩写=%1$ta", calendar)); System.out.println(String.format(Locale.CHINA, "Locale.CHINA 星期几=%1$tA，缩写=%1$ta", calendar)); System.out.println(String.format("'C':年份除以100的结果，显示两位数，不足两位前面补0：%tC（范围：00-99）", calendar)); System.out.println(String.format("'Y':显示四位数的年份，格利高里历，即公历。不足四位前面补0：%tY", calendar)); System.out.println(String.format("'y':显示年份的后两位：%ty（范围：00-99）", calendar)); System.out.println(String.format("'j':显示当前公历年的天数：第%tj天（范围：001-366）", calendar)); System.out.println(String.format("'m':显示当前月份：%tm月（范围：01-13？怎么会有13个月？）", calendar)); System.out.println(String.format("'d':显示是当前月的第几天，不足两位前面补0：%1$tm月第%1$td天（范围：01-31）", calendar)); System.out.println(String.format("'e':显示是当前月的第几天：%1$tm月第%1$te天（范围：1-31）", calendar));&#125; 输出如下： 1234567891011121314151617这是格式化时间相关的，具体输出跟你执行代码时间有关'B':本地化显示月份字符串，如：January、February'b':本地化显示月份字符串的缩写，如：Jan、Feb'h':本地化显示月份字符串的缩写，效果同'b'Locale.US 月份=June，缩写=JunLocale.CHINA 月份=六月，缩写=6月'A':本地化显示星期几字符串，如：Sunday、Monday'a':本地化显示星期几字符串的缩写，如：Sun、MonLocale.US 星期几=Sunday，缩写=SunLocale.CHINA 星期几=星期日，缩写=周日'C':年份除以100的结果，显示两位数，不足两位前面补0：20（范围：00-99）'Y':显示四位数的年份，格利高里历，即公历。不足四位前面补0：2018'y':显示年份的后两位：18（范围：00-99）'j':显示当前公历年的天数：第161天（范围：001-366）'m':显示当前月份：06月（范围：01-13？怎么会有13个月？）'d':显示是当前月的第几天，不足两位前面补0：06月第10天（范围：01-31）'e':显示是当前月的第几天：06月第10天（范围：1-31） 时间日期格式化： 12345678910111213141516171819/** * 格式化时间日期 */private static void formatTimeAndDate() &#123; System.out.println("这是格式化时间相关的，具体输出跟你执行代码时间有关"); Calendar calendar = Calendar.getInstance(); //%tH:%tM的缩写 System.out.println(String.format("'R':将时间格式化为：HH:MM（24小时制）。输出：%tR", calendar)); //%tH:%tM:%tS的缩写 System.out.println(String.format("'T':将时间格式化为：HH:MM:SS（24小时制）。输出：%tT", calendar)); //%tI:%tM:%tS %Tp的缩写，输出形如： System.out.println(String.format("'r':将时间格式化为：09:23:15 下午，跟设置的语言地区有关。输出：%tr", calendar)); //%tm/%td/%ty的缩写，输出形如 System.out.println(String.format("'D':将时间格式化为：10/19/16。输出：%tD", calendar)); //%tY-%tm-%td，输出形如： System.out.println(String.format("'F':将时间格式化为：2016-10-19。输出：%tF", calendar)); //%ta %tb %td %tT %tZ %tY，输出形如：Sun Jul 20 16:17:00 EDT 1969 System.out.println(String.format("'c':将时间格式化为\"Sun Jul 20 16:17:00 EDT 1969\"。输出：%tc", calendar));&#125; 输出如下： 12345678910111213141516171819/** * 格式化时间日期 */private static void formatTimeAndDate() &#123; System.out.println("这是格式化时间相关的，具体输出跟你执行代码时间有关"); Calendar calendar = Calendar.getInstance(); //%tH:%tM的缩写 System.out.println(String.format("'R':将时间格式化为：HH:MM（24小时制）。输出：%tR", calendar)); //%tH:%tM:%tS的缩写 System.out.println(String.format("'T':将时间格式化为：HH:MM:SS（24小时制）。输出：%tT", calendar)); //%tI:%tM:%tS %Tp的缩写，输出形如： System.out.println(String.format("'r':将时间格式化为：09:23:15 下午，跟设置的语言地区有关。输出：%tr", calendar)); //%tm/%td/%ty的缩写，输出形如 System.out.println(String.format("'D':将时间格式化为：10/19/16。输出：%tD", calendar)); //%tY-%tm-%td，输出形如： System.out.println(String.format("'F':将时间格式化为：2016-10-19。输出：%tF", calendar)); //%ta %tb %td %tT %tZ %tY，输出形如：Sun Jul 20 16:17:00 EDT 1969 System.out.println(String.format("'c':将时间格式化为\"Sun Jul 20 16:17:00 EDT 1969\"。输出：%tc", calendar));&#125; 参考文档：踏歌行—Java 字符串格式化详解Java API – Formatterlonely_fireworks的专栏—JAVA字符串格式化-String.format()的使用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python使用sys.stdin与fileinput获取标准输入]]></title>
    <url>%2Fpython%2Fpython%E4%BD%BF%E7%94%A8sys-stdin%E4%B8%8Efileinput%E8%8E%B7%E5%8F%96%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Shell脚本可以直接利用管道衔接不同的Linux命令，通过管道可以使用多个简单的命令实现复杂的功能。在Python中也希望可以利用管道。 stdinPython的标准库sys提供了三个文件描述符: 标准输入 标准输出 错误输出 stdin stdout stderr 以下例子是获取标准输入，然后写入到标准输入。read_stdin.py1234import sysfor line in sys.stdin: sys.stdout.write(line) 接下来我们可以在命令行使用该脚本。123$ cat /etc/passwd | python read_stdin.py$ python read_stdin.py &lt; /etc/passwd$ python read_stdin.py - sys.stdin为文件描述符，故拥有文件对象的方法，我们可以使用read()方法读取标准输入的所有内容，或者使用readlines()将标准输入内容读取到一个list中。 upper.py12345678import sysdef get_upper_list(): content_list = sys.stdin.readlines() return [i.upper() for i in content_list]for line in get_upper_list(): sys.stdout.write(line) 上述脚本中定义了get_content()函数，该函数使用sys.stdin标准输入的readlines()方法读取所有行，以列表类型保存于content_list，使用列表解析，调用每个元素(字符串类型)的upper()方法，构造一个新的列表并返回。迭代get_upper_list()函数返回的新列表，将每一行写入标准输入。 该脚本运行效果如下： 利用sys.stdin，我们几乎可以不再使用awk。将Python与Linux管道结合，可以充分发挥Python语言的文字处理能力。 fileinput对于awk，它可以同时处理多个文件，在Python中我们可以使用fileinput这个标准库来达到同样效果。fileinput比sys.stdin更为通用，它可以遍历sys.argv[1:]列表(所有命令行参数)中的文件，如果该列表为空(没有提供文件名参数)，则默认读取标准输入的内容。 read_from_fileinput.py1234import fileinputfor line in fileinput.input(): print(line, end="") 上述脚本直接调用了fileinput模块的input函数，该函数返回一个FileInput实例化的可迭代对象，可以使用for循环遍历取得每一行内容。fileinput既可以从标准输入读取数据，也可以从文件中(一个或多个)读取数据。12345$ python read_from_fileinput.py - # 从标准输入读取数据$ cat /etc/passwd | python read_from_fileinput.py # 通过管道读取passwd数据$ python read_from_fileinput.py &lt; /etc/passwd # 通过重定向读取passwd数据$ python read_from_fileinput.py /etc/passwd # 直接读取passwd文件数据$ python read_from_fileinput.py /etc/passwd /etc/hosts # 直接读取passwd与hosts文件数据 fileinput还提供了一些方法让我们知道当前读取的内容属于哪一个文件等便利的方法，常用方法如下： filename: 当前正在读取文件的文件名 str fileno: 文件的描述符 int filelineno: 正在读取的行时当前文件的第几行 int isfirstline: 正在读取的行是否是当前文件的第一行 bool isstdin: 正在读的问价是否时从标准输入读取的 bool nextfile: 关闭当前正在读取的文件，从下一个文件第一行开始 None 我们可以完成一个简单的脚本来展示一下fileinput的各个方法： read_file.py1234567891011import fileinputfor line in fileinput.input(): meta = ["文件名:" + str(fileinput.filename()), " 文件描述符:" + str(fileinput.fileno()), " 行号:" + str(fileinput.filelineno()), " 首行:" + str(fileinput.isfirstline()), " 标准输入:" + str(fileinput.isstdin()) + " "] meta_ljust = [i.ljust(9) for i in meta] print(*meta_ljust, end="") print(line, end="") 同时fileinput还提供了钩子函数，可以帮助去自定义文件访问的方式：fileinput内置了两个函数：hook_compressed: 识别并打开.gz和.bz2的压缩文件hook_encoded: 以特定的编码格式打开文件 读取一个.gz压缩文件，如下所示：read_compressed.py1234import fileinputfor line in fileinput.input(openhook=fileinput.hook_compressed): print(line.decode('utf-8'), end="") 在中文windows下有读取utf-8,或在linux下读取gbk需要指定对应的编码格式，如下所示： read_encoded.py1234import fileinputfor line in fileinput.input(openhook=fileinput.hook_encoded(encoding="gbk")): print(line, end="")]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo与Gitpages搭建博客]]></title>
    <url>%2Fhexo%2F%E4%BD%BF%E7%94%A8Hexo%E4%B8%8EGitpages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Hexo与Gitpages搭建博客一直使用为知笔记这款笔记软件来整理并记录自己学习的和感兴趣的东西。但是近段时间为知笔记的会员过期了，也不想每年花钱用这些笔记软件。忽然萌生出写博客这个想法。因为单纯想作为个人笔记使用，想要自己折腾折腾，所以不考虑使用博客园，CSDN这类的技术博客。经过一番搜索，调查，觉得用gitpages来托管静态页面这个方式还是挺适合的，不需要买云空间，而且也有现成的框架。 各种度娘，谷歌，折腾了一番，这个Blog也差不多能用了，趁热打铁，整理一下搭建过程。 搭建本地Hexo运行环境我们需要先在本地搭建Hexo运行环境，安装Hexo并初始化我们的博客，然后进行一些配置修改，使其可以本地正常访问。 了解Hexo Hexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的标签插件来快速的插入特定形式的内容，而且相对于其他框架，Hexo在速度上也有很大优势。 Hexo Git版本管理工具安装Git是目前世界上最先进的分布式版本控制系统。我们可以使用它对代码，文档等文件进行版本管理。在本次博客搭建过程中，它的主要作用是帮助我们从github远程仓库获取各种工具，以及将Hexo生成的静态页面同步到远程仓库。而且对Windows来说可以使用其minitty作为命令行的替代。 Windows：下载并安装 git。 Mac：使用 Homebrew, MacPorts ：brew install git；或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows用户 由于天朝众所周知的原因，下载git会非常缓慢，建议使用代理。或者可以参考这里Git for Windows 国内下载站。 如果想学习Git的使用，推荐一下廖老师的教程 廖雪峰的官方网站 Node.js环境搭建由于Hexo是基于Node.js，所以我们必须先准备好Node.js环境。 了解Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 Node Node.js安装使用nvm来安装Node.jsWget使用cURL安装$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 使用Wget安装$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后重启终端，执行以下命令安装Node.js1nvm install stable 也可以直接下载安装程序执行安装 安装hexo使用Node.js的包管理工具npm安装hexo1npm install -g hexo-cli 安装完成后，可以在命令行终端试一下hexo是否可以使用 若不能使用，可以检查以下几方面： npm install过程是否有异常 检查环境变量是否正常，安装时会在/usr/bin/中创建hexo可执行程序的软链接 若链接不存在，检查/usr/lib/node_modules/hexo/bin/hexo是否存在，手工在/usr/bin/下创建链接ln -s /usr/lib/node_modules/hexo/bin/hexo /usr/bin/hexo 使用Hexo建站初始化使用如下命令，hexo可以在一个指定文件夹(blog)中创建所需文件 123$ hexo init blog$ cd blog$ npm install 完成后使用tree blog可以得到目录树如下 12345678.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。├── package.json # 应用程序的信息。├── scaffolds # 模版文件夹。新建文章时，Hexo会根据 scaffold 来建立文件。├── source # 资源文件夹是存放用户资源的地方| ├── _drafts| └── _posts└── themes # 主题文件夹。Hexo会根据主题来生成静态页面。 Hexo基本配置在blog目录下，_config.yml中为用户可以自定义的配置，我们可以从Hexo官网了解各个参数的意义。下面列出我搭建时的修改项。 12345678# Sitetitle: Shadowlesssubtitle: 备忘录description: 求知若饥，虚心若愚keywords: blogauthor: Shadowlesslanguage: zh-CNtimezone: Asia/Shanghai 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言，如：zh-CN timezone 网站时区。Hexo 默认使用您电脑的时区。如：Asia/Shanghai 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://shadowless.toproot: /# permalink: :year/:month/:day/:title/permalink: :category/:title/permalink_defaults: 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 以上参数自定义完成后可以执行hexo g生成静态页面 然后输入命令hexo s --debug，以debug模式启动hexo的server模块 待启动成功后可以使用浏览器输入本地回环地址http://localhost:4000/ or http://127.0.0.1:4000/访问你所创建的博客页面。 以上基本配置已经完成，接下来我们来学习一下文章的创建，主题的配置，以及将本地搭建完成的博客部署到gitgub。 新建文章我们可以使用 hexo new post “文章名”来新建一篇文章新建的内容会在blog/source/_posts/目录中，由你指定的文章名命名，后缀为.md。我们可以直接使用markdown语法编写该文件。 将博客部署到GithubGithub账户与仓库配置新建仓库首先我们打开“全球最大同性交友网站gayhub”，然后注册一个账户。 登录账户，在网页上方状态栏找到一个加号，点击New repository。 接下来会让你填写仓库名称，这里需要填写的格式为：用户名.github.io。如图所示，设置为public仓库，可以不用README初始化仓库，也可以不添加.gitignore和license。然后点击下方Create repository即可。 完成后我们会跳转至该仓库，在该页会有在本地添加远程仓库的指导以及HTTPS和SSH链接。 配置SSH keys我们选择使用ssh进行部署。需要生成一对ssh认证的密钥，然后将公钥添加到你的github账户。 分为如下步骤: 检查SSH keys是否存在 生成新的ssh key 将ssh key添加到GitHub中 keys所在目录为~/.ssh/中，检查目标文件id_rsa, id_rsa.pub是否存在。 若文件不存在，我们需要重新生成密钥。在命令行中输入ssh-keygen -t rsa -C &quot;your_email@example.com&quot;，为了方便可以一路按回车，不需要输入其他内容，默认会在相应路径下（/your_home_path）生成id_rsa和id_rsa.pub两个文件，如下面代码所示 1234ssh-keygen -t rsa -C "your_email@example.com"# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/your_home_path/.ssh/id_rsa): 将新生成的key添加到ssh-agent中: 1234# start the ssh-agent in the backgroundeval "$(ssh-agent -s)"Agent pid 59566ssh-add ~/.ssh/id_rsa 将ssh key添加到GitHub中: 打开Github，点击右上角加号，选择Settings 选择左侧一列中SSH and GPG keys。 选择New SSH key。 打开本地~/.ssh/id_rsa.pub文件将其中内容复制出来，粘贴到github页面key的输入框中。 点击 add SSH Key完成添加 修改配置文件打开博客根目录下的_config.yml配置文件，找到deploy一栏，按照如下模板填写。 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: 你github仓库的SSH链接 branch: master message: update my blog 将博客部署到远程首先我们需要生成网页的静态文件：1hexo generate 然后使用命令将生成的静态文件PUSH到github远程仓库：1hexo deploy 等待完成后可以访问你的用户名.github.io来进入博客了。 每次更新文章后都可以使用hexo generate生成静态文件，再hexo deploy将其push到github。 后续会增加关于Next主题的配置 HOME]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2Fother%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[折腾了两个晚上，翻了几篇教程，终于将这个Blog搭起来了。想在这里记录一下自己的学习，工作，生活，就当是一个记事本啦。 先记录一下搭建时参考的教程吧： 1.首先时hexo的官方文档 https://hexo.io/zh-cn/docs/ 2.接下来时NexT主题的相关配置 https://www.jianshu.com/p/3ff20be8574c 后面我也会总结一下自己的搭建过程。 顺便测试一下图床七牛云]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
